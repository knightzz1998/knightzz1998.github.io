const e=JSON.parse('{"key":"v-24af44df","path":"/service/Netty/NIO%E5%85%A5%E9%97%A8.html","title":"JavaNIO编程","lang":"zh-CN","frontmatter":{"title":"JavaNIO编程","icon":"note","date":"2022-01-12T00:00:00.000Z","category":["Netty实战"],"description":"JavaNIO编程 1.NIO基本介绍 Java NIO 全称 java non-blocking IO，是指 JDK 提供的新API。从 JDK1.4 开始，Java 提供了一系列改进的输入/输出 的新特性，被统称为 NIO(即 New IO)，是同步非阻塞的 NIO 相关类都被放在 java.nio 包及子包下，并且对原 java.io 包中的很多类进行改写 NIO 有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector(选择器) NIO是 面向缓冲区 ，或者面向 块 编程的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络 Java NIO的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线 程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这 个线程同时可以去做别的事情。【后面有案例说明】 通俗理解：NIO是可以做到用一个线程来处理多个操作的。假设有10000个请求过来,根据实际情况，可以分配50或者100个线程来处理。不像之前的阻塞IO那样，非得分 配10000个。 HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。","head":[["meta",{"property":"og:url","content":"https://knightzz1998.github.io/service/Netty/NIO%E5%85%A5%E9%97%A8.html"}],["meta",{"property":"og:site_name","content":"十里平湖霜满天"}],["meta",{"property":"og:title","content":"JavaNIO编程"}],["meta",{"property":"og:description","content":"JavaNIO编程 1.NIO基本介绍 Java NIO 全称 java non-blocking IO，是指 JDK 提供的新API。从 JDK1.4 开始，Java 提供了一系列改进的输入/输出 的新特性，被统称为 NIO(即 New IO)，是同步非阻塞的 NIO 相关类都被放在 java.nio 包及子包下，并且对原 java.io 包中的很多类进行改写 NIO 有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector(选择器) NIO是 面向缓冲区 ，或者面向 块 编程的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络 Java NIO的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线 程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这 个线程同时可以去做别的事情。【后面有案例说明】 通俗理解：NIO是可以做到用一个线程来处理多个操作的。假设有10000个请求过来,根据实际情况，可以分配50或者100个线程来处理。不像之前的阻塞IO那样，非得分 配10000个。 HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-02-23T12:00:20.000Z"}],["meta",{"property":"article:published_time","content":"2022-01-12T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-02-23T12:00:20.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JavaNIO编程\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-01-12T00:00:00.000Z\\",\\"dateModified\\":\\"2023-02-23T12:00:20.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"1.NIO基本介绍","slug":"_1-nio基本介绍","link":"#_1-nio基本介绍","children":[]},{"level":2,"title":"2.NIO与BIO的比较","slug":"_2-nio与bio的比较","link":"#_2-nio与bio的比较","children":[]},{"level":2,"title":"3.NIO核心原理","slug":"_3-nio核心原理","link":"#_3-nio核心原理","children":[{"level":3,"title":"核心组件关系图","slug":"核心组件关系图","link":"#核心组件关系图","children":[]},{"level":3,"title":"缓冲区","slug":"缓冲区","link":"#缓冲区","children":[]},{"level":3,"title":"通道","slug":"通道","link":"#通道","children":[]},{"level":3,"title":"选择器","slug":"选择器","link":"#选择器","children":[]},{"level":3,"title":"NIO非阻塞编程","slug":"nio非阻塞编程","link":"#nio非阻塞编程","children":[]}]},{"level":2,"title":"4.NIO编程","slug":"_4-nio编程","link":"#_4-nio编程","children":[{"level":3,"title":"NIO入门案例","slug":"nio入门案例","link":"#nio入门案例","children":[]},{"level":3,"title":"SelectionKey","slug":"selectionkey","link":"#selectionkey","children":[]},{"level":3,"title":"ServerSocketChannel","slug":"serversocketchannel","link":"#serversocketchannel","children":[]},{"level":3,"title":"SocketChannel","slug":"socketchannel","link":"#socketchannel","children":[]},{"level":3,"title":"群聊系统实现","slug":"群聊系统实现","link":"#群聊系统实现","children":[]}]},{"level":2,"title":"5.NIO与零拷贝","slug":"_5-nio与零拷贝","link":"#_5-nio与零拷贝","children":[{"level":3,"title":"零拷贝","slug":"零拷贝","link":"#零拷贝","children":[]},{"level":3,"title":"零拷贝案例","slug":"零拷贝案例","link":"#零拷贝案例","children":[]}]},{"level":2,"title":"6.NIO存在的问题","slug":"_6-nio存在的问题","link":"#_6-nio存在的问题","children":[]},{"level":2,"title":"7.JavaAIO","slug":"_7-javaaio","link":"#_7-javaaio","children":[]}],"git":{"createdTime":1673531771000,"updatedTime":1677153620000,"contributors":[{"name":"王天赐","email":"15565946702@163.com","commits":3}]},"readingTime":{"minutes":26.01,"words":7802},"filePathRelative":"service/Netty/NIO入门.md","localizedDate":"2022年1月12日","excerpt":"<h1> JavaNIO编程</h1>\\n<h2> 1.NIO基本介绍</h2>\\n<blockquote>\\n<p><strong>Java NIO</strong> 全称 <code>java non-blocking IO</code>，是指 JDK 提供的新API。从 JDK1.4 开始，Java 提供了一系列改进的输入/输出\\n的新特性，被统称为 NIO(即 New IO)，是同步非阻塞的</p>\\n</blockquote>\\n<ul>\\n<li>NIO 相关类都被放在 java.nio 包及子包下，并且对原 <code>java.io</code> 包中的很多类进行改写</li>\\n<li>NIO 有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector(选择器)</li>\\n<li>NIO是 面向缓冲区 ，或者面向 块 编程的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络</li>\\n<li>Java NIO的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线\\n程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这\\n个线程同时可以去做别的事情。【后面有案例说明】</li>\\n<li>通俗理解：NIO是可以做到用一个线程来处理多个操作的。假设有10000个请求过来,根据实际情况，可以分配50或者100个线程来处理。不像之前的阻塞IO那样，非得分\\n配10000个。</li>\\n<li>HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。</li>\\n</ul>","autoDesc":true}');export{e as data};
